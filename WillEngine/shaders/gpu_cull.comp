#version 460

#extension GL_EXT_buffer_reference : require
#extension GL_GOOGLE_include_directive : require

#include "indirect_input_structures.glsl"

layout(local_size_x = 64) in;

struct MeshData
{
	vec3 position;
	float radius;
};

struct VkDrawIndexedIndirectCommand
{
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	int  vertexOffset;
	uint firstInstance;
};



layout(buffer_reference, std430) readonly buffer MeshDataBuffer
{
	MeshData meshData[];
};

layout(buffer_reference, std430) buffer CommandBuffer
{
	VkDrawIndexedIndirectCommand commands[];
};

layout(set = 1, binding = 0) uniform command_buffer_addresses
{
	CommandBuffer opaque_command_buffer;
	uint opaque_command_buffer_count;
	CommandBuffer transparent_command_buffer;
	uint transparent_command_buffer_count;
	MeshDataBuffer mesh_data_buffer;
	vec3 padding;
} command_buffer_address;


// See "VisibilityTester" in the C++ code for explanation
bool check_is_visible(mat4 mat, vec3 origin, float radius)
{
	uint plane_index = 0;
	for (uint i = 0; i < 3; ++i)
	{
		for (uint j = 0; j < 2; ++j, ++plane_index)
		{
			if (plane_index == 2 || plane_index == 3)
			{
				continue;
			}
			const float sign  = (j > 0) ? 1.f : -1.f;
			vec4        plane = vec4(0, 0, 0, 0);
			for (uint k = 0; k < 4; ++k)
			{
				plane[k] = mat[k][3] + sign * mat[k][i];
			}
			plane.xyzw /= sqrt(dot(plane.xyz, plane.xyz));
			if (dot(origin, plane.xyz) + plane.w + radius < 0)
			{
				return false;
			}
		}
	}
	return true;
}

void main()
{
	uint invoc_number = gl_GlobalInvocationID.x;
	uint total_command_count = command_buffer_address.opaque_command_buffer_count + command_buffer_address.transparent_command_buffer_count;
	if (invoc_number >= total_command_count) { return; }

	uint instance_id = 0;
	uint command_index = 0;
	// Do not modify the value of firstInstance
	if (invoc_number >= command_buffer_address.opaque_command_buffer_count) {  
		command_index = invoc_number - command_buffer_address.opaque_command_buffer_count;
		instance_id = command_buffer_address.transparent_command_buffer.commands[command_index].firstInstance;
	} else {
		command_index = invoc_number;
		instance_id = command_buffer_address.opaque_command_buffer.commands[command_index].firstInstance;
	}
	

	// get model matrix and mesh id
	Model m = buffer_addresses.modelBufferDeviceAddress.models[instance_id];
	mat4 modelMatrix = m.model;
	uint meshIndex = m.mesh_index;

	// get mesh data w/ mesh index
	MeshData mesh = command_buffer_address.mesh_data_buffer.meshData[meshIndex];
	vec3 position = mesh.position;
	float radius = mesh.radius;

	// transform position to clip space
	position = vec3(modelMatrix * vec4(position, 1.0));

	// check if in frustum
	bool is_visible = check_is_visible(sceneData.viewproj, position, radius);
	uint final_instance_count = is_visible ? 1 : 0;
	// update instance count based on visibility
	if (invoc_number >= command_buffer_address.opaque_command_buffer_count) {  
		command_buffer_address.transparent_command_buffer.commands[command_index].instanceCount = final_instance_count;
	} else {
		command_buffer_address.opaque_command_buffer.commands[command_index].instanceCount = final_instance_count;
	}
}
